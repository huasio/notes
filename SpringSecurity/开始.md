# 版本编号
Spring Security 版本的格式为 MAJOR.MINOR.PATCH，这样：

- MAJOR：可能包含重大更改。通常，这样做是为了提供改进的安全性以匹配现代安全实践。
- MINOR：版本包含增强功能，但被视为被动更新
- PATCH：级别应该完全兼容，向前和向后，修复错误的更改可能除外。

# 与 Maven 一起使用
与大多数开源项目一样，Spring Security 将其依赖项部署为 Maven 工件。

## 使用 Maven 启动 Spring
Spring Boot 提供了一个 starter，将 Spring Security 相关的依赖聚合在一起。使用 starter 的最简单和首选的方法是通过使用 IDE 集成（Eclipse、IntelliJ、NetBeans）或通过 https://start.spring.io `spring-boot-starter-security` 使用 Spring Initializr

1. pom.xml

```xml
<dependencies>
    <!-- ... other dependency elements ... -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
```

由于 Spring Boot 提供了 Maven BOM 来管理依赖版本，因此无需指定版本。如果希望覆盖 Spring Security 版本，可以通过提供 Maven 属性来实现，如以下示例所示：

2. pom.xml

```xml
<properties>
    <!-- ... -->
    <spring-security.version>5.5.3</spring-security.version>
</dependencies>
```

由于 Spring Security 仅在主要版本中进行重大更改，因此在 Spring Boot 中使用较新版本的 Spring Security 是安全的。但是，有时可能还需要更新 Spring Framework 的版本。可以通过添加 Maven 属性来实现，如以下示例所示：

3. pom.xml

```xml
<properties>
    <!-- ... -->
    <spring.version>5.3.11</spring.version>
</dependencies>
```

如果使用附加功能（例如 LDAP、OpenID 等），还需要包含适当的[项目模块和依赖项](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#modules)。

## 没有 Spring Boot 的 Maven
当您在不使用 Spring Boot 的情况下使用 Spring Security 时，首选方法是使用 Spring Security 的 BOM 以确保在整个项目中使用一致的 Spring Security 版本。以下示例显示了如何执行此操作：

4. pom.xml

```xml
<dependencyManagement>
    <dependencies>
        <!-- ... other dependency elements ... -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-bom</artifactId>
            <version>{spring-security-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

Spring Security 针对 Spring Framework 5.3.11 构建，但通常应与 Spring Framework 5.x 的任何更新版本一起使用。许多用户可能会与 Spring Security 的传递依赖项解决 Spring Framework 5.3.11 的事实发生冲突，这可能会导致奇怪的类路径问题。解决此问题的最简单方法是在部分中使用，如下例所示：`spring-framework-bom <dependencyManagement> pom.xml`

6. pom.xml

```xml
<dependencyManagement>
    <dependencies>
        <!-- ... other dependency elements ... -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-framework-bom</artifactId>
            <version>5.3.11</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

## Maven 存储库
所有 GA 版本（即以 .RELEASE 结尾的版本）都部署到 Maven Central，因此不需要在 pom 中声明额外的 Maven 存储库。

如果使用 SNAPSHOT 版本，则需要确保已定义 Spring Snapshot 存储库，如以下示例所示：

7. pom.xml

```xml
<repositories>
    <!-- ... possibly other repository elements ... -->
    <repository>
        <id>spring-snapshot</id>
        <name>Spring Snapshot Repository</name>
        <url>https://repo.spring.io/snapshot</url>
    </repository>
</repositories>
```

如果使用里程碑或发布候选版本，则需要确保已定义 Spring Milestone 存储库，如以下示例所示：

8. pom.xml

```xml
<repositories>
    <!-- ... possibly other repository elements ... -->
    <repository>
        <id>spring-milestone</id>
        <name>Spring Milestone Repository</name>
        <url>https://repo.spring.io/milestone</url>
    </repository>
</repositories>
```

# Gradle

与大多数开源项目一样，Spring Security 将其依赖项部署为 Maven 工件，这允许一流的 Gradle 支持。以下主题提供了有关在使用 Gradle 时如何使用 Spring Security 的详细信息。

## 带有 Gradle 的 Spring Boot
手动添加启动器，如以下示例所示：

9. build.gradle

```groovy
dependencies {
    compile "org.springframework.boot:spring-boot-starter-security"
}
```

由于 Spring Boot 提供了 Maven BOM 来管理依赖版本，因此无需指定版本。如果希望覆盖 Spring Security 版本，可以通过提供 Gradle 属性来实现，如以下示例所示：

10. build.gradle

```groovy
ext['spring-security.version']='5.5.3'
```

由于 Spring Security 仅在主要版本中进行重大更改，因此在 Spring Boot 中使用较新版本的 Spring Security 是安全的。但是，有时可能还需要更新 Spring Framework 的版本。可以通过添加 Gradle 属性来实现，如以下示例所示：

11. build.gradle

```groovy
ext['spring.version']='5.3.11'
```

## 没有 Spring Boot 的 Gradle
当不使用 Spring Boot 的情况下使用 Spring Security 时，首选方法是使用 Spring Security 的 BOM 以确保在整个项目中使用一致的 Spring Security 版本。可以通过使用依赖管理插件来实现，如以下示例所示：

12. build.gradle

```groovy
plugins {
    id "io.spring.dependency-management" version "1.0.6.RELEASE"
}

dependencyManagement {
    imports {
        mavenBom 'org.springframework.security:spring-security-bom:5.5.3'
    }
}
```

一组最小的 Spring Security 依赖项通常如下所示：

13. build.gradle

```groovy
dependencies {
    compile "org.springframework.security:spring-security-web"
    compile "org.springframework.security:spring-security-config"
}
```

## Gradle 存储库
所有 GA 版本（即以 .RELEASE 结尾的版本）都部署到 Maven Central，因此对于 GA 版本使用 mavenCentral() 存储库就足够了。以下示例显示了如何执行此操作：

15. build.gradle

```groovy
repositories {
    mavenCentral()
}
```

如果使用 SNAPSHOT 版本，则需要确保已定义 Spring Snapshot 存储库，如以下示例所示：

16. build.gradle

```groovy
repositories {
    maven { url 'https://repo.spring.io/snapshot' }
}
```

如果使用里程碑或发布候选版本，则需要确保已定义 Spring Milestone 存储库，如以下示例所示：

17. build.gradle

```groovy
repositories {
    maven { url 'https://repo.spring.io/milestone' }
}
```

# 验证（Authentication）
Spring Security 为身份验证提供了全面的支持。身份验证是我们验证尝试访问特定资源的人的身份的方式。验证用户身份的常用方法是要求用户输入用户名和密码。一旦执行身份验证，我们就知道身份并可以执行授权。

## 认证支持
Spring Security 提供了对用户身份验证的内置支持。有关每个堆栈支持的内容的详细信息，请参阅有关 [Servlet](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-authentication) 和 WebFlux 身份验证的部分。

## 密码存储
Spring Security 的接口会对密码的进行加密和校验，以允许安全地存储密码。鉴于是一种单向转换，当密码转换需要两种方式（即存储用于对数据库进行身份验证的凭据）时，不打算这样做。通常用于存储需要在身份验证时与用户提供的密码进行比较的密码。



**DelegatingPasswordEncoder**

密码加密，可以构建不同的密码加密方案，典型的使用默认的方案，当然，可以自由的创建自定义的密码加密器。

使用默认的密码加密实例：

```java
PasswordEncoder passwordEncoder =
    PasswordEncoderFactories.createDelegatingPasswordEncoder();
```

创建自定义的密码加密器：

```java
String idForEncode = "bcrypt";
Map encoders = new HashMap<>();
encoders.put(idForEncode, new BCryptPasswordEncoder());
encoders.put("noop", NoOpPasswordEncoder.getInstance());
encoders.put("pbkdf2", new Pbkdf2PasswordEncoder());
encoders.put("scrypt", new SCryptPasswordEncoder());
encoders.put("sha256", new StandardPasswordEncoder());

PasswordEncoder passwordEncoder =
    new DelegatingPasswordEncoder(idForEncode, encoders);
```

## 密码存储格式

密码的一般格式是：

```
{id}encodedPassword
```

这样 id 是用于查找应该使用哪个 PasswordEncoder 的标识符，encodedPassword 是所选 PasswordEncoder 的原始编码密码。 id 必须在密码的开头，以 { 开头，以 } 结尾。如果找不到 id，则 id 将为空。例如，以下可能是使用不同 id 编码的密码列表。所有原始密码都是“密码”。

```
{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG 
{noop}password 
{pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc 
{scrypt}$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=  
{sha256}97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0
```

- 第一个密码的 PasswordEncoder id 为 bcrypt，encodedPassword 为 $2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG。
  匹配时，它将委托给 BCryptPasswordEncoder
- 第二个密码的 PasswordEncoder id 为 noop，encodedPassword 为密码。
  匹配时，它将委托给 NoOpPasswordEncoder
- 第三个密码的 PasswordEncoder id 为 pbkdf2，encodedPassword 为 5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc。
  匹配时，它将委托给 Pbkdf2PasswordEncoder
- 第四个密码的 PasswordEncoder id 为 scrypt，encodedPassword 为 $e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g25+OHPYeUp4of4g25+OHPYcYpZ0xPYcYpYcYpYcYpYcYpYcYuXPYcYpYcYpYcYpXuXPYcYpXuXPYcYpYcYpXfOc/9bdYSrN1oD9qfVThWEwdRTn
  匹配时，它将委托给 SCryptPasswordEncoder
- 最后一个密码的 PasswordEncoder id 为 sha256，encodedPassword 为 97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0。
  匹配时，它将委托给 StandardPasswordEncoder

## 使用 Spring Boot CLI 进行编码

正确编码密码的最简单方法是使用 Spring Boot CLI。
例如，以下将对密码的密码进行编码以与 DelegatingPasswordEncoder 一起使用：

Spring Boot CLI encodepassword Example

```none
spring encodepassword password
{bcrypt}$2a$10$X5wFBtLrL/kHcmrOGGTrGufsBX8CJ0WpQpF3pgeuxBB/H73BK1DW6
```



## 加密方案

**BCryptPasswordEncoder**

BCryptPasswordEncoder 实现使用广泛支持的 bcrypt 算法来散列密码。为了使其更能抵抗密码破解，bcrypt 特意慢了下来。与其他自适应单向函数一样，应该将其调整为大约需要 1 秒来验证系统上的密码。 BCryptPasswordEncoder 的默认实现使用强度 10，如 BCryptPasswordEncoder 的 Javadoc 中所述。我们鼓励您在自己的系统上调整和测试强度参数，以便验证密码大约需要 1 秒。

```java
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16);
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
```



**Argon2PasswordEncoder**

Argon2PasswordEncoder 实现使用 Argon2 算法来散列密码。 Argon2 是密码哈希竞赛的获胜者。为了打败自定义硬件上的密码破解，Argon2 是一种需要大量内存的故意慢速算法。与其他自适应单向函数一样，应该将其调整为大约需要 1 秒来验证系统上的密码。 Argon2PasswordEncoder 的当前实现需要 BouncyCastle。

```java
Argon2PasswordEncoder encoder = new Argon2PasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
```



**Pbkdf2PasswordEncoder**

Pbkdf2PasswordEncoder 实现使用 PBKDF2 算法来散列密码。为了打败密码破解，PBKDF2 是一种故意慢速的算法。与其他自适应单向函数一样，应该将其调整为大约需要 1 秒来验证系统上的密码。当需要 FIPS 认证时，此算法是一个不错的选择。

```java
Pbkdf2PasswordEncoder encoder = new Pbkdf2PasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
```



**SCryptPasswordEncoder**

SCryptPasswordEncoder 实现使用 scrypt 算法来散列密码。为了在自定义硬件上破解密码，scrypt 是一种需要大量内存的故意慢速算法。与其他自适应单向函数一样，应该将其调整为大约需要 1 秒来验证系统上的密码。

```java
SCryptPasswordEncoder encoder = new SCryptPasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
```



**Other PasswordEncoders**

还有大量其他 PasswordEncoder 实现完全是为了向后兼容而存在的。它们都被弃用，表明它们不再被认为是安全的。但是，由于难以迁移现有的遗留系统，因此没有删除它们的计划。



## 密码存储配置

Spring Security 默认使用DelegatingPasswordEncoder。然而，这可以通过公开一个 spring bean 来定制。

如果是从 Spring Security 4.2.x 迁移，可以通过公开 bean NoOpPasswordEncoder 来恢复到以前的行为。

> 恢复到不被认为是安全的，应该改为使用支持安全密码编码。

```java
@Bean
public static NoOpPasswordEncoder passwordEncoder() {
    return NoOpPasswordEncoder.getInstance();
}
```

## 防止漏洞利用
Spring Security 提供针对常见漏洞的保护。在可能的情况下，默认情况下启用保护。

### 跨站请求伪造 (CSRF)

Spring 为防止[跨站点请求伪造 (CSRF)](https://en.wikipedia.org/wiki/Cross-site_request_forgery) 攻击提供全面支持。

- [What is a CSRF Attack?](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-explained)
- [Protecting Against CSRF Attacks](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection)
- [CSRF Considerations](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-considerations)

### 防范 CSRF 攻击
之所以可能发生CSRF攻击，是因为受害者网站的HTTP请求和攻击者网站的请求完全相同。这意味着无法拒绝来自邪恶网站的请求并允许来自银行网站的请求。为了防止 CSRF 攻击，我们需要确保请求中存在恶意站点无法提供的内容，以便我们可以区分这两个请求。

Spring 提供了两种机制来防止 CSRF 攻击：

- 同步器令牌模式
- 在会话 cookie 上指定 [SameSite](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection-ssa) 属性

**两种保护都要求[安全方法必须是幂等](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection-idempotent)的**

### 安全方法必须是幂等的
为了使针对 CSRF 的保护起作用，应用程序必须确保“安全”的 HTTP 方法是幂等的。

```

```

