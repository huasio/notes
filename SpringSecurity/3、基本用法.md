[TOC]

# 基本认证

## 快速入门

在 Spring Boot 项目中使用 Spring Security 非常简单，只要通过引入依赖就可以开箱即用，不用做任何的配置。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```



之后创建一个简单的用于测试的接口：

```java
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "hello spring security";
    }
}
```

将项目跑起来之后，访问该接口就会被拦截下来，需要登录之后才能访问，因为 Spring Security 此时已经对项目进行保护。

![](https://huasio.com/upload/2021/11/Snipaste_2021-11-12_22-14-14-30d06738ebbf421fbf180395fdbb7a9b.png)

Spring Security 默认的登录用户名：user，密码每次在项目启动的时候随机生成，并且输出到控制台。

```
Using generated security password: 88dc63da-80ea-49c8-bf14-447bbb39bbd9
```



## 流程分析

![](https://huasio.com/upload/2021/11/Snipaste_2021-11-13_20-49-05-0c72880cf240465496e74c4b005b903f.png)



从流程图可以看出来，比较清晰的表达了这个流程走向。

1. 客户端（一般是浏览器）发起请求访问 /hello 接口，该接口默认是需要认证之后才能访问。
2. 该请求会走一遍 Spring Security 中的过滤器链，在最后的 FilterSecurityInterceptor 过滤器中被拦截下来，此时系统发现用户未认证。请求拦截下来之后，会抛出 AccessDeinedException 异常。
3. 抛出的 AccessDeinedException 异常在 ExceptionTranslationFilter 过滤器中被捕获，ExceptionTranslationFilter 过滤器通过调用 LoginUrlAuthenticationEntryPoint#commence 方法给客户端放回 302，要求客户端重定向到 /login 页面。
4. 客户端发送 /login 请求。
5. /login 请求被 DefaultLoginPageGeneratingFilter 过滤器拦截下来，并在该过滤器中返回登录页面。

整个过程，客户端相当于发送了两次请求，第一次请求 /hello，服务端收到请求后，返回 302，要求客户端重定向到 /login 页面，于是客户端又发送了 /login 请求。



## 原理分析

通过上面的一个简单引入 Spring Security 依赖，代码并没有多少，这简单背后是 Spring Boot 在处理一些重复性的配置工作。

- 开启了 Spring Security 自动化配置，开启后，会自动创建一个名为 springSecurityFilterChain 的过滤器，并且注入到容器中。这个过滤器将负责所有的安全管理，包括用户的认证、授权、重定向到登录页面等等工作（springSecurityFilterChain 实际上代理了 Spring Security 中的过滤器链）。
- 创建一个 UserDetailsService 实例，UserDetailsService 负责提供用户数据，默认的用户数据是居于内存的用户，用户名为 user，密码则是随机生成的 UUID 字符串。
- 给用户生成一个默认的登录页面
- 开启 CSRF 攻击防御
- 开启会话固定攻击防御
- 集成 X-XSS-Protection
- 集成 X-Frame-Options 以防止单击劫持



### 默认用户生成

Spring Security 定义了 UserDetails 接口来规范开发自定义的用户对象，方便一些旧系统、用户表已经固定的系统集成到 Spring Security 认证体系中。

#### UserDetails：规范化用户对象接口

```java
public interface UserDetails extends Serializable {

	Collection<? extends GrantedAuthority> getAuthorities();

	String getPassword();

	String getUsername();

	boolean isAccountNonExpired();

	boolean isAccountNonLocked();

	boolean isCredentialsNonExpired();

	boolean isEnabled();

}
```

接口方法不多，一共 7 个：

- getAuthorities：返回当前账户所具备的权限
- getPassword：返回当前账户的密码
- getUsername：返回当前账户的用户名
- isAccountNonExpired：返回当前账户是否未过期
- isAccountNonLocked：返回当前账户是否未锁定
- isCredentialsNonExpired：返回当前账户凭证（如密码）是否未过期
- isEnabled：返回当前账户是否可用



#### UserDetailsService：提供用户数据的接口

这个接口只有一个方法，就是根据用户名称获取用户数据。

```java
public interface UserDetailsService {

	UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;

}
```

- loadUserByUsername：根据用户名查询用户数据



这个 username 就是用户认证的时候传入的用户名，例如说表单登录时账号密码。

实际项目中，通常都会自定义 UserDetailsService 接口的实现类，当前 Spring Security 默认提供一个实现类。

![](https://huasio.com/upload/2021/11/Snipaste_2021-11-13_21-30-21-f25ea6c6730741e18e712a98e3b26fef.png)



- UserDetailsManager 接口在 UserDetailsService 基础上，继续定义了添加用户、更新用户、删除用户、修改密码以及判断用户是否存在几个方法。
- JdbcDaoImpl 在 UserDetailsService 基础上，通过 spring-jdbc 实现了从数据库中查询用户的方法
- ImMemoryUserDetailsManager 实现了 UserDetailsManager 中关于用户的增删改查方法，这些都是基于内存的操作，数据没有持久化
- JdbcUserDetailsManager 继承自 JdbcDaoImpl，同时又实现了 UserDetailsManager 接口，除了增删改查之外，这些操作都会持久化到数据库中。不过这个实现类的局限性在于 SQL 都是实现写好的，缺少灵活性，这个类用的不多。
- CachingUserDetailsService 的特点就是会将用户数据缓存起来
- UserDetailsServiceDelegator 则提供了 UserDetailsService 的懒加载功能
- ReactiveUserDetailsServiceAdapter 是 webflux-web-security 模块定义的 UserDetailsService 实现的。



Spring Security 默认使用的用户就是 InMemoryUserDetailsManager 提供的。



#### UserDetailsServiceAutoConfiguration：自动配置加载类

Spring Security 之所以引入依赖就能使用的，是因为 Spring Boot 在背后默默的处理配置，其中关于 UserDetailsService 的自动化配置是 UserDetailsServiceAutoConfiguration 类完成的。

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(AuthenticationManager.class)
@ConditionalOnBean(ObjectPostProcessor.class)
@ConditionalOnMissingBean(
		value = { AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class },
		type = { "org.springframework.security.oauth2.jwt.JwtDecoder",
				"org.springframework.security.oauth2.server.resource.introspection.OpaqueTokenIntrospector" })
public class UserDetailsServiceAutoConfiguration {

	private static final String NOOP_PASSWORD_PREFIX = "{noop}";

	private static final Pattern PASSWORD_ALGORITHM_PATTERN = Pattern.compile("^\\{.+}.*$");

	private static final Log logger = LogFactory.getLog(UserDetailsServiceAutoConfiguration.class);

	@Bean
	@ConditionalOnMissingBean(
			type = "org.springframework.security.oauth2.client.registration.ClientRegistrationRepository")
	@Lazy
	public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties,
			ObjectProvider<PasswordEncoder> passwordEncoder) {
		SecurityProperties.User user = properties.getUser();
		List<String> roles = user.getRoles();
		return new InMemoryUserDetailsManager(
				User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))
						.roles(StringUtils.toStringArray(roles)).build());
	}

	private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) {
		String password = user.getPassword();
		if (user.isPasswordGenerated()) {
			logger.info(String.format("%n%nUsing generated security password: %s%n", user.getPassword()));
		}
		if (encoder != null || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) {
			return password;
		}
		return NOOP_PASSWORD_PREFIX + password;
	}

}
```



这个类主要处理的工作就是默认加载这个 InMemoryUserDetailsManager 实现类。

当满足两个条件的时候，这个类就会被加载 Spring 容器中。

1. 当前 classpath 类路径下存在 AuthenticationManager 类。
2. 当前项目中，系统在这之外没有加载过 AuthenticationManager、AuthenticationProvider、UserDetailsService 以及 ClientRegistrationRepository 实例。

默认情况下，以上条件都会满足。



针对默认加载的 InMemoryUserDetailsManager 类，以及默认生成的密码，会经过 getOrDeducePassword 进行二次处理，当然这里是没有 PasswordEncoder 实现类的，所以默认密码就是没有加密，在密码的前面拼了前缀：`{noop}`



可以看这个默认加载的 InMemoryUserDetailManager 实现代码很简单。

```java
@ConfigurationProperties(prefix = "spring.security")
public class SecurityProperties {
    // 省略
	public static class User {

		private String name = "user";
		private String password = UUID.randomUUID().toString();
        private List<String> roles = new ArrayList<>();
        
        // 省略
	}
    // 省略
}

```

看到这里，我们想要自定义默认用户的信息的话，可以通过在配置文件中配置如下内容，就可以改变用户的默认规则：

```properties
spring.security.name=username
spring.security.password=password
spring.security.roles=admin,user
```

重启项目之后，下次登录的默认用户就是这里配置的。



### 默认页面生成

默认的登录页面和注销页面由以下两个过滤器提供：

- DefaultLoginPageGeneratingFilter：生成默认登录页面
- DefaultLogoutPageGeneratingFilter：生成默认注销页面

#### DefaultLoginPageGeneratingFilter

首先是登录页面生成的过滤器，这个过滤器只会处理登录接口，默认的是 /login。

这个过滤器会处理以下情况：

- 是登录接口
- 登录失败
- 注销成功

满足上面任意一种情况，都会生成一个登录页面，并且通过 HttpServletResponse 将登录页面写回到前端，然后 return 跳出过滤器链。

```java
private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
    throws IOException, ServletException {
    boolean loginError = isErrorPage(request);
    boolean logoutSuccess = isLogoutSuccess(request);
    if (isLoginUrlRequest(request) || loginError || logoutSuccess) {
        String loginPageHtml = generateLoginPageHtml(request, loginError, logoutSuccess);
        response.setContentType("text/html;charset=UTF-8");
        response.setContentLength(loginPageHtml.getBytes(StandardCharsets.UTF_8).length);
        response.getWriter().write(loginPageHtml);
        return;
    }
    chain.doFilter(request, response);
}
```



#### DefaultLogoutPageGeneratingFilter

这个接口的代码比较少，这里做了判断，只要请求匹配 matcher 这个对象，那么就渲染一个注销页面，大致逻辑与生成登录页面一样。

```java
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
    private RequestMatcher matcher = new AntPathRequestMatcher("/logout", "GET");

    throws ServletException, IOException {
    if (this.matcher.matches(request)) {
        renderLogout(request, response);
    }
    else {
        if (logger.isTraceEnabled()) {
            logger.trace(LogMessage.format("Did not render default logout page since request did not match [%s]",
                                           this.matcher));
        }
        filterChain.doFilter(request, response);
    }
}
```



# 登录表单配置

## 快速入门

创建一个 Spring Boot 项目，添加以下两个依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```



在项目中 resources/static 目录下，创建一个登录页面：login.html，这个登录页面有几点需要注意的地方：

1. login.html 需要与 Spring Security 配置的 loginPage 一样，默认会在 resources/static 目录下寻找同名文件。
2. form 的 action，这里需要与 Spring Security 配置的 loginProcessingUrl 一样。
3. 表单中的用户名和密码的字段也需要与 Spring Security 配置的 usernameParameter、passwordParameter 一样。



 Spring Security 配置：

```java
@Configuration
public class MySpringSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .loginPage("/login.html")
                .loginProcessingUrl("/doLogin")
                .defaultSuccessUrl("/index")
                .failureUrl("/login.html")
                .usernameParameter("username")
                .passwordParameter("password")
                .permitAll()
                .and()
                .csrf().disable();
    }
}
```

实现自定义的 Spring Security 配置类，基本上都是继承 WebSecurityConfigurerAdapter 来重写其中某些方法。

重写的 configure 方法中是一个链式配置语法，也可以不用链式配置语法，每一个属性配置完成之后，重新使用 http 对象配置，这里代码具体作用如下：

- authorizeRequest 开启权限配置（这个方法还有其它含义），anyRequest().authenticated() 表示所有的请求都要认证之后才能访问。
- and 方法返回 HttpSecurity 实例，可以重新开始下一轮的配置。
- formLogin 表示开启表单登录配置，loginPage 用来配置登录页面地址，loginProcessingUrl 用来配置登录处理接口地址，defaultSuccessUrl 用来配置等成功后默认调整的地址，failureUrl 用来配置登录失败后跳转的地址，usernameParameter 用来配置登录用户名，passwordParameter 用来配置登录密码。permitAll 表示这一轮配置中所有接口和页面都不拦截，直接通过。
- csrf().disable() 表示禁用 csrf 防御功能，默认是开启的。



通过以上的配置，就完成了自定义的登录配置和权限相关的内容。



## 配置细节





# 登录用户数据获取

# 用户的四种定义方式

