[TOC]

# 基本认证

## 快速入门

在 Spring Boot 项目中使用 Spring Security 非常简单，只要通过引入依赖就可以开箱即用，不用做任何的配置。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```



之后创建一个简单的用于测试的接口：

```java
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "hello spring security";
    }
}
```

将项目跑起来之后，访问该接口就会被拦截下来，需要登录之后才能访问，因为 Spring Security 此时已经对项目进行保护。

![](https://huasio.com/upload/2021/11/Snipaste_2021-11-12_22-14-14-30d06738ebbf421fbf180395fdbb7a9b.png)

Spring Security 默认的登录用户名：user，密码每次在项目启动的时候随机生成，并且输出到控制台。

```
Using generated security password: 88dc63da-80ea-49c8-bf14-447bbb39bbd9
```



## 流程分析

![](https://huasio.com/upload/2021/11/Snipaste_2021-11-13_20-49-05-0c72880cf240465496e74c4b005b903f.png)



从流程图可以看出来，比较清晰的表达了这个流程走向。

1. 客户端（一般是浏览器）发起请求访问 /hello 接口，该接口默认是需要认证之后才能访问。
2. 该请求会走一遍 Spring Security 中的过滤器链，在最后的 FilterSecurityInterceptor 过滤器中被拦截下来，此时系统发现用户未认证。请求拦截下来之后，会抛出 AccessDeinedException 异常。
3. 抛出的 AccessDeinedException 异常在 ExceptionTranslationFilter 过滤器中被捕获，ExceptionTranslationFilter 过滤器通过调用 LoginUrlAuthenticationEntryPoint#commence 方法给客户端放回 302，要求客户端重定向到 /login 页面。
4. 客户端发送 /login 请求。
5. /login 请求被 DefaultLoginPageGeneratingFilter 过滤器拦截下来，并在该过滤器中返回登录页面。

整个过程，客户端相当于发送了两次请求，第一次请求 /hello，服务端收到请求后，返回 302，要求客户端重定向到 /login 页面，于是客户端又发送了 /login 请求。



## 原理分析

通过上面的一个简单引入 Spring Security 依赖，代码并没有多少，这简单背后是 Spring Boot 在处理一些重复性的配置工作。

- 开启了 Spring Security 自动化配置，开启后，会自动创建一个名为 springSecurityFilterChain 的过滤器，并且注入到容器中。这个过滤器将负责所有的安全管理，包括用户的认证、授权、重定向到登录页面等等工作（springSecurityFilterChain 实际上代理了 Spring Security 中的过滤器链）。
- 创建一个 UserDetailsService 实例，UserDetailsService 负责提供用户数据，默认的用户数据是居于内存的用户，用户名为 user，密码则是随机生成的 UUID 字符串。
- 给用户生成一个默认的登录页面
- 开启 CSRF 攻击防御
- 开启会话固定攻击防御
- 集成 X-XSS-Protection
- 集成 X-Frame-Options 以防止单击劫持



### 默认用户生成

Spring Security 定义了 UserDetails 接口来规范开发自定义的用户对象，方便一些旧系统、用户表已经固定的系统集成到 Spring Security 认证体系中。

#### UserDetails：规范化用户对象接口

```java
public interface UserDetails extends Serializable {

	Collection<? extends GrantedAuthority> getAuthorities();

	String getPassword();

	String getUsername();

	boolean isAccountNonExpired();

	boolean isAccountNonLocked();

	boolean isCredentialsNonExpired();

	boolean isEnabled();

}
```

接口方法不多，一共 7 个：

- getAuthorities：返回当前账户所具备的权限
- getPassword：返回当前账户的密码
- getUsername：返回当前账户的用户名
- isAccountNonExpired：返回当前账户是否未过期
- isAccountNonLocked：返回当前账户是否未锁定
- isCredentialsNonExpired：返回当前账户凭证（如密码）是否未过期
- isEnabled：返回当前账户是否可用



#### UserDetailsService：提供用户数据的接口

这个接口只有一个方法，就是根据用户名称获取用户数据。

```java
public interface UserDetailsService {

	UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;

}
```

- loadUserByUsername：根据用户名查询用户数据



这个 username 就是用户认证的时候传入的用户名，例如说表单登录时账号密码。

实际项目中，通常都会自定义 UserDetailsService 接口的实现类，当前 Spring Security 默认提供一个实现类。

![](https://huasio.com/upload/2021/11/Snipaste_2021-11-13_21-30-21-f25ea6c6730741e18e712a98e3b26fef.png)



- UserDetailsManager 接口在 UserDetailsService 基础上，继续定义了添加用户、更新用户、删除用户、修改密码以及判断用户是否存在几个方法。
- JdbcDaoImpl 在 UserDetailsService 基础上，通过 spring-jdbc 实现了从数据库中查询用户的方法
- ImMemoryUserDetailsManager 实现了 UserDetailsManager 中关于用户的增删改查方法，这些都是基于内存的操作，数据没有持久化
- JdbcUserDetailsManager 继承自 JdbcDaoImpl，同时又实现了 UserDetailsManager 接口，除了增删改查之外，这些操作都会持久化到数据库中。不过这个实现类的局限性在于 SQL 都是实现写好的，缺少灵活性，这个类用的不多。
- CachingUserDetailsService 的特点就是会将用户数据缓存起来
- UserDetailsServiceDelegator 则提供了 UserDetailsService 的懒加载功能
- ReactiveUserDetailsServiceAdapter 是 webflux-web-security 模块定义的 UserDetailsService 实现的。



Spring Security 默认使用的用户就是 InMemoryUserDetailsManager 提供的。



#### UserDetailsServiceAutoConfiguration：自动配置加载类

Spring Security 之所以引入依赖就能使用的，是因为 Spring Boot 在背后默默的处理配置，其中关于 UserDetailsService 的自动化配置是 UserDetailsServiceAutoConfiguration 类完成的。

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(AuthenticationManager.class)
@ConditionalOnBean(ObjectPostProcessor.class)
@ConditionalOnMissingBean(
		value = { AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class },
		type = { "org.springframework.security.oauth2.jwt.JwtDecoder",
				"org.springframework.security.oauth2.server.resource.introspection.OpaqueTokenIntrospector" })
public class UserDetailsServiceAutoConfiguration {

	private static final String NOOP_PASSWORD_PREFIX = "{noop}";

	private static final Pattern PASSWORD_ALGORITHM_PATTERN = Pattern.compile("^\\{.+}.*$");

	private static final Log logger = LogFactory.getLog(UserDetailsServiceAutoConfiguration.class);

	@Bean
	@ConditionalOnMissingBean(
			type = "org.springframework.security.oauth2.client.registration.ClientRegistrationRepository")
	@Lazy
	public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties,
			ObjectProvider<PasswordEncoder> passwordEncoder) {
		SecurityProperties.User user = properties.getUser();
		List<String> roles = user.getRoles();
		return new InMemoryUserDetailsManager(
				User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))
						.roles(StringUtils.toStringArray(roles)).build());
	}

	private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) {
		String password = user.getPassword();
		if (user.isPasswordGenerated()) {
			logger.info(String.format("%n%nUsing generated security password: %s%n", user.getPassword()));
		}
		if (encoder != null || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) {
			return password;
		}
		return NOOP_PASSWORD_PREFIX + password;
	}

}
```



这个类主要处理的工作就是默认加载这个 InMemoryUserDetailsManager 实现类。

当满足两个条件的时候，这个类就会被加载 Spring 容器中。

1. 当前 classpath 类路径下存在 AuthenticationManager 类。
2. 当前项目中，系统在这之外没有加载过 AuthenticationManager、AuthenticationProvider、UserDetailsService 以及 ClientRegistrationRepository 实例。

默认情况下，以上条件都会满足。



针对默认加载的 InMemoryUserDetailsManager 类，以及默认生成的密码，会经过 getOrDeducePassword 进行二次处理，当然这里是没有 PasswordEncoder 实现类的，所以默认密码就是没有加密，在密码的前面拼了前缀：`{noop}`



可以看这个默认加载的 InMemoryUserDetailManager 实现代码很简单。

```java
@ConfigurationProperties(prefix = "spring.security")
public class SecurityProperties {
    // 省略
	public static class User {

		private String name = "user";
		private String password = UUID.randomUUID().toString();
        private List<String> roles = new ArrayList<>();
        
        // 省略
	}
    // 省略
}

```

看到这里，我们想要自定义默认用户的信息的话，可以通过在配置文件中配置如下内容，就可以改变用户的默认规则：

```properties
spring.security.name=username
spring.security.password=password
spring.security.roles=admin,user
```

重启项目之后，下次登录的默认用户就是这里配置的。



### 默认页面生成

默认的登录页面和注销页面由以下两个过滤器提供：

- DefaultLoginPageGeneratingFilter：生成默认登录页面
- DefaultLogoutPageGeneratingFilter：生成默认注销页面

#### DefaultLoginPageGeneratingFilter

首先是登录页面生成的过滤器，这个过滤器只会处理登录接口，默认的是 /login。

这个过滤器会处理以下情况：

- 是登录接口
- 登录失败
- 注销成功

满足上面任意一种情况，都会生成一个登录页面，并且通过 HttpServletResponse 将登录页面写回到前端，然后 return 跳出过滤器链。

```java
private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
    throws IOException, ServletException {
    boolean loginError = isErrorPage(request);
    boolean logoutSuccess = isLogoutSuccess(request);
    if (isLoginUrlRequest(request) || loginError || logoutSuccess) {
        String loginPageHtml = generateLoginPageHtml(request, loginError, logoutSuccess);
        response.setContentType("text/html;charset=UTF-8");
        response.setContentLength(loginPageHtml.getBytes(StandardCharsets.UTF_8).length);
        response.getWriter().write(loginPageHtml);
        return;
    }
    chain.doFilter(request, response);
}
```



#### DefaultLogoutPageGeneratingFilter

这个接口的代码比较少，这里做了判断，只要请求匹配 matcher 这个对象，那么就渲染一个注销页面，大致逻辑与生成登录页面一样。

```java
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
    private RequestMatcher matcher = new AntPathRequestMatcher("/logout", "GET");

    throws ServletException, IOException {
    if (this.matcher.matches(request)) {
        renderLogout(request, response);
    }
    else {
        if (logger.isTraceEnabled()) {
            logger.trace(LogMessage.format("Did not render default logout page since request did not match [%s]",
                                           this.matcher));
        }
        filterChain.doFilter(request, response);
    }
}
```



# 登录表单配置

## 快速入门

创建一个 Spring Boot 项目，添加以下两个依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```



在项目中 resources/static 目录下，创建一个登录页面：login.html，这个登录页面有几点需要注意的地方：

1. login.html 需要与 Spring Security 配置的 loginPage 一样，默认会在 resources/static 目录下寻找同名文件。
2. form 的 action，这里需要与 Spring Security 配置的 loginProcessingUrl 一样。
3. 表单中的用户名和密码的字段也需要与 Spring Security 配置的 usernameParameter、passwordParameter 一样。



 Spring Security 配置：

```java
@Configuration
public class MySpringSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .loginPage("/login.html")
                .loginProcessingUrl("/doLogin")
                .defaultSuccessUrl("/index")
                .failureUrl("/login.html")
                .usernameParameter("username")
                .passwordParameter("password")
                .permitAll()
                .and()
                .csrf().disable();
    }
}
```

实现自定义的 Spring Security 配置类，基本上都是继承 WebSecurityConfigurerAdapter 来重写其中某些方法。

重写的 configure 方法中是一个链式配置语法，也可以不用链式配置语法，每一个属性配置完成之后，重新使用 http 对象配置，这里代码具体作用如下：

- authorizeRequest 开启权限配置（这个方法还有其它含义），anyRequest().authenticated() 表示所有的请求都要认证之后才能访问。
- and 方法返回 HttpSecurity 实例，可以重新开始下一轮的配置。
- formLogin 表示开启表单登录配置，loginPage 用来配置登录页面地址，loginProcessingUrl 用来配置登录处理接口地址，defaultSuccessUrl 用来配置等成功后默认调整的地址，failureUrl 用来配置登录失败后跳转的地址，usernameParameter 用来配置登录用户名，passwordParameter 用来配置登录密码。permitAll 表示这一轮配置中所有接口和页面都不拦截，直接通过。
- csrf().disable() 表示禁用 csrf 防御功能，默认是开启的。



通过以上的配置，就完成了自定义的登录配置和权限相关的内容。



## 登录成功

### defaultSuccessUrl、successForwardUrl：登录成功跳转

表示用户登录成功后跳转的地址，这两个方法都是实现登录成功跳转到某一个地址，但是，它们还有一点区别的。

- defaultSuccessUrl 表示当用户登录成功之后，会自动重定向到登录之前的地址，如果用户本身就是直接访问登录页面的，那么登录成功之后重定向到 defaultSuccessUrl 设置的地址。

- successForwardUrl 不会考虑用户之前的访问地址，这个方法设置了什么地址，登录成功之后会通过服务端跳转到这个地址。

defaultSuccessUrl  还有另外一个重载方法，当设置为 true 的时候，则效果与 successForwardUrl 一样，一个是重定向，一个是服务端跳转，它们都是配置的 AuthenticationSuccessHandler 接口的实例。



#### AuthenticationSuccessHandler：登录成功之后的处理接口

```java
public interface AuthenticationSuccessHandler {

	default void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, FilterChain chain,
			Authentication authentication) throws IOException, ServletException {
		onAuthenticationSuccess(request, response, authentication);
		chain.doFilter(request, response);
	}

	void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
			Authentication authentication) throws IOException, ServletException;

}
```

这里两个方法，其中一个 default 方法是在处理特定认证请求 Authentication Filter，另外一个非 default 方法用来处理登录成功的具体事项。



##### 实现类：SimpleUrlAuthenticationSuccessHandler

继承 AbstractAuthenticationTargetUrlRequestHandler，通过AbstractAuthenticationTargetRequestHandler 的 handle 方法实现重定向。



##### 实现类：SavedRequestAwareAuthenticationSuccessHandler

在 SimpleUrlAuthenticationSuccessHandler 的基础上增加了请求缓存的功能，可以记录之前的请求地址，所以在登录成功之后可以重定向到一开始访问的地址，defaultSuccessUrl 这个方法设置的地址，就是该类来处理的。

```java
public class SavedRequestAwareAuthenticationSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

	protected final Log logger = LogFactory.getLog(this.getClass());

	private RequestCache requestCache = new HttpSessionRequestCache();

	@Override
	public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
			Authentication authentication) throws ServletException, IOException {
		SavedRequest savedRequest = this.requestCache.getRequest(request, response);
		if (savedRequest == null) {
			super.onAuthenticationSuccess(request, response, authentication);
			return;
		}
		String targetUrlParameter = getTargetUrlParameter();
		if (isAlwaysUseDefaultTargetUrl()
				|| (targetUrlParameter != null && StringUtils.hasText(request.getParameter(targetUrlParameter)))) {
			this.requestCache.removeRequest( request, response);
			super.onAuthenticationSuccess(request, response, authentication);
			return;
		}
		clearAuthenticationAttributes(request);
		// Use the DefaultSavedRequest URL
		String targetUrl = savedRequest.getRedirectUrl();
		getRedirectStrategy().sendRedirect(request, response, targetUrl);
	}

	public void setRequestCache(RequestCache requestCache) {
		this.requestCache = requestCache;
	}

}
```

onAuthenticationSuccess 方法处理逻辑：

- 从 requestCache 方法获取缓存下来的请求，如果没有则直接调用父类的方法重定向到指定地址
- 设置总是跳转到指定地址，登录成功之后会跳转到指定地址
- 设置了跳转参数 key，并且访问的时候有显式设置跳转 url，在登录成功之后，跳转到指定地址
- 上面情况都不满足的时候，会获取缓存的请求地址，登录成功之后会重定向到缓存的请求地址



##### 实现类：ForwardAuthenticationSuccessHandler

这个类实现比较简单，就是通过 request 实现服务端跳转。



successForward 这个方法就是配置这个类，代码接口比较简单，就是通过 request 的服务端转发。

```java
public class ForwardAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

	private final String forwardUrl;

	/**
	 * @param forwardUrl
	 */
	public ForwardAuthenticationSuccessHandler(String forwardUrl) {
		Assert.isTrue(UrlUtils.isValidRedirectUrl(forwardUrl), () -> "'" + forwardUrl + "' is not a valid forward URL");
		this.forwardUrl = forwardUrl;
	}

	@Override
	public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
			Authentication authentication) throws IOException, ServletException {
		request.getRequestDispatcher(this.forwardUrl).forward(request, response);
	}

}
```



##### 自定义实现类

在流行前后端分离的软件设计中，这种默认的登录成功之后的处理器是无法满足要求的，需要我们自定义 AuthenticationSuccessHandler 接口的实现类，返回其它的数据格式给前端，而不是页面。

```java
public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        response.setContentType("application/json;charset=utf-8");

        Map<String, Object> map = new HashMap<>();
        map.put("code", 200);
        map.put("msg", "登录成功");
        response.getWriter().write((new ObjectMapper()).writeValueAsString(map));
    }
}
```

然后配置登录处理的时候，设置 successHandler 这个方法，而不是 defaultSuccessUrl 和 successForwardUrl 这两个方法。

```java
@Configuration
public class MySpringSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin()
				// 省略
                .successHandler(new MyAuthenticationSuccessHandler())
               // 省略
    }
}
```



## 登录失败

### failureUrl、failureForawardUrl：登录失败处理

这两个方法类似登录成功跳转地址的那两个方法，failureUrl 方法是重定向，failureForwardUrl 是服务端跳转。

重定向不方便携带错误信息，服务端跳转可以可以通过请求域等方式携带错误信息。



这两个方法配置的都是 AuthenticationFailureHandler 接口的实例。

#### AuthenticationFailureHandler：登录失败处理的接口

````java
public interface AuthenticationFailureHandler {

   void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
         AuthenticationException exception) throws IOException, ServletException;

}
```

onAuthenticationFailure 这个方法用来处理登录失败的处理逻辑，exception 包含错误信息。



##### 实现类：SimpleUrlAuthenticationFailureHandler

默认处理逻辑是通过重定向回到登陆页面，可以通过配置 forwardToDesination 属性将重定向改为服务端跳转，failureUrl 方法底层实现就是 SimpleUrlAuthenticationFailureHandler 类。

```java
public class SimpleUrlAuthenticationFailureHandler implements AuthenticationFailureHandler {

	protected final Log logger = LogFactory.getLog(getClass());

	private String defaultFailureUrl;

	private boolean forwardToDestination = false;

	private boolean allowSessionCreation = true;

	private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

	public SimpleUrlAuthenticationFailureHandler() {
	}

	public SimpleUrlAuthenticationFailureHandler(String defaultFailureUrl) {
		setDefaultFailureUrl(defaultFailureUrl);
	}
    
	@Override
	public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
			AuthenticationException exception) throws IOException, ServletException {
		if (this.defaultFailureUrl == null) {
			if (this.logger.isTraceEnabled()) {
				this.logger.trace("Sending 401 Unauthorized error since no failure URL is set");
			}
			else {
				this.logger.debug("Sending 401 Unauthorized error");
			}
			response.sendError(HttpStatus.UNAUTHORIZED.value(), HttpStatus.UNAUTHORIZED.getReasonPhrase());
			return;
		}
		saveException(request, exception);
		if (this.forwardToDestination) {
			this.logger.debug("Forwarding to " + this.defaultFailureUrl);
			request.getRequestDispatcher(this.defaultFailureUrl).forward(request, response);
		}
		else {
			this.redirectStrategy.sendRedirect(request, response, this.defaultFailureUrl);
		}
	}
    
	protected final void saveException(HttpServletRequest request, AuthenticationException exception) {
		if (this.forwardToDestination) {
			request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);
			return;
		}
		HttpSession session = request.getSession(false);
		if (session != null || this.allowSessionCreation) {
			request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);
		}
	}
    
    public void setUseForward(boolean forwardToDestination) {
		this.forwardToDestination = forwardToDestination;
	}
    // 省略......
}
```



onAuthenticationFailure 方法的处理逻辑：

- 如果没有设置 defaultFailureUrl 指定地址，那么通过 response 返回异常信息
- 设置了失败 defaultFailureUrl 指定地址，判断是否指定 forwardToDestination 为 true 采用服务端跳转。如果是，那么会通过 request 服务端跳转的方式返回异常信息，此时的异常信息会保存的 request 请求域中，前端页面可以通过你 ${SPRING_SECURITY_LAST_EXCEPTION} 变量获取到异常信息；如果不是，那么会以重定向的方式跳转到登录页，同时异常信息会保存在 session 中。



##### 实现类：ExceptionMappingAuthenticationFailureHandler

继承 SimpleUrlAuthenticationFailureHandler，可以通过不同的异常类型，映射到不同的路径。



##### 实现类：ForwardAuthenticationFailureHandler

通过服务端跳转回到登录页面，failureForwardUrl 方法的底层实现逻辑就是 ForwardAuthenticationFailureHandler 类。



##### 实现类：AuthenticationEntryPointFailureHandler

该类是 Spring Security 5.2 新引入的类，可以通过 AuthenticationEntryPoint 来处理异常。



##### 实现类：DelegatingAuthenticationFailureHandler

可以实现为不同的异常配置不同的登录失败处理回调。



##### 自定义实现类

同样是在前后端分离的软件开发当中，是不需要返回页面的，只需要返回类似 JSON 格式这样的数据就行，所以这种情况就需要我们自定义实现类，默认类无法满足要求。

```java
public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
        response.setContentType("application/json;charset=utf-8");

        HashMap<String, Object> map = new HashMap<>();
        map.put("code", 401);
        map.put("msg", String.format("登录失败，原因：%s", exception.getMessage()));
        response.getWriter().write((new ObjectMapper()).writeValueAsString(map));
    }
}
```

之后在 SecurityConfig 中进行配置即可。

```java
@Configuration
public class MySpringSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .successHandler(new MyAuthenticationSuccessHandler())
                .failureHandler(new MyAuthenticationFailureHandler())
                // 省略......
    }
}
```



## 注销登录

Spring Security 提供默认的注销页面，但是开发者也可以通过相关接口另外实现。

```java
@Configuration
public class MySpringSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .logout()
                .logoutUrl("/logout.html")
                .invalidateHttpSession(true)
                .clearAuthentication(true)
                .logoutSuccessUrl("/login.html");
    }
}
```

- logout：表示开启注销登录配置
- logoutUrl：注销登录请求地址，默认是 GET，路径为：/logout
- invalidateHttpSession：表示是否让 session 失效，默认为 true
- clearAuthentication：表示是否清楚认证信息，默认为 true
- logoutSuccessHandler：设置注销登录成功后跳转的地址



### LogoutSuccessHandler：注销登录处理器接口

该接口对于登录成功、登录失败处理器接口类似，都是相同的做法。



#### 实现类：SimpleUrlLogoutSuccessHandler

继承 AbstractAuthenticationTargetUrlRequestHandler 类，这个类是重定向处理逻辑。



#### 实现类：ForwardLogoutSuccessHandler

该类是使用 request 服务端跳转的方式。



#### 实现类：HttpStatusReturningLogoutSuccessHandler

返回状态码，没有其它任何信息。



#### 实现类：DelegatingLogoutSuccessHandler

允许不同请求对应不同的处理逻辑。



### 配置多个注销地址

```java
@Configuration
public class MySpringSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .logout()
                .logoutRequestMatcher(new OrRequestMatcher(new AntPathRequestMatcher("/logout", "GET"), new AntPathRequestMatcher("/logout", "POST")))
                .invalidateHttpSession(true)
                .clearAuthentication(true)
                .logoutSuccessUrl("/login.html");
    }
}
```

logoutRequestMatcher 方法可以设置多个路径匹配，以及不同的请求方式。

### 返回 JSON 数据

在前后端分离的软件开发中，是不需要返回页面的，所以我们需要自定义处理类，可以返回一些数据格式的结果。



只需要实现 LogoutSuccessHandler 接口即可，怎么处理就可以自定编写逻辑。

```java
public LogoutSuccessHandler logoutSuccessHandler() {
    return new LogoutSuccessHandler() {
        @Override
        public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
            response.setContentType("application/json;charset=utf-8");
            Map<String, Object> map = new HashMap<>();
            map.put("code", 200);
            map.put("msg", "注销成功");
            response.getWriter().write((new ObjectMapper()).writeValueAsString(map));
        }
    };
}
```



### 针对不同路径的处理逻辑

```java
package com.huasio.springsecurity.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.huasio.springsecurity.handler.MyAuthenticationFailureHandler;
import com.huasio.springsecurity.handler.MyAuthenticationSuccessHandler;
import org.springframework.beans.factory.annotation.Configurable;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.security.web.util.matcher.OrRequestMatcher;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * @author yu
 */
@Configuration
public class MySpringSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated()
                .and()
                .logout()
                .logoutRequestMatcher(new OrRequestMatcher(new AntPathRequestMatcher("/logout", "GET"), new AntPathRequestMatcher("/logout", "POST")))
                .invalidateHttpSession(true)
                .clearAuthentication(true)
                .defaultLogoutSuccessHandlerFor(logoutSuccessHandler1(), new AntPathRequestMatcher("/logout", "GET"))
                .defaultLogoutSuccessHandlerFor(logoutSuccessHandler2(), new AntPathRequestMatcher("/logout", "POST"));
    }

    public LogoutSuccessHandler logoutSuccessHandler1() {
        return new LogoutSuccessHandler() {
            @Override
            public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
                response.setContentType("application/json;charset=utf-8");
                Map<String, Object> map = new HashMap<>();
                map.put("code", 200);
                map.put("msg", "注销成功");
                response.getWriter().write((new ObjectMapper()).writeValueAsString(map));
            }
        };
    }

    public LogoutSuccessHandler logoutSuccessHandler2() {
        return new LogoutSuccessHandler() {
            @Override
            public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
                response.setContentType("application/json;charset=utf-8");
                Map<String, Object> map = new HashMap<>();
                map.put("code", 200);
                map.put("msg", "注销成功");
                response.getWriter().write((new ObjectMapper()).writeValueAsString(map));
            }
        };
    }
}
```





# 登录用户数据获取

# 用户的四种定义方式

